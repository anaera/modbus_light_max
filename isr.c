#include "modbus.h"
#include "timers.h"
#include "isr.h"
#include "const.h"
#include "masterI2C.h"
//------------------------------------------------------------------------------
/**
 * \file
 * \brief Обработчик прерываний для приема и передачи пакетов протокола MODBUS.
 * 
 * Поскольку изначально неизвестна длина принимаемого пакета данных МОДБАСА,
 * окончание пакета определяется отсутствием новых данных RxUSART в течении
 * интервала GAPTIME, который считается в переменной MODBUS.gapCnt
 * от GAPTIME до нуля.
 * Режим работы uUSART полудуплекс. 
 * Во время приема передатчик выключен и прерывания от него запрещены.
 * После приема пакета (определяется по интервалу тишины) приемник выключается 
 * прерывания запрещаются. Автомат переходит врежим обработки принятого пакета и
 * формируется пакет ответа. Разрешается работа передатчика и прерывания от него.
 * Автомат переходит в состояние простоя на фоне которого происходит передача.
 * После отправки данных пакета в передатчик USART автомат переходит в режим
 * завершения передачи, запрещения работы передатчика и прерываний передачи,
 * инициализации параметров приема, разрешения работы приемника прерыва  
 * инициализации параметров приема, разрешения работы приемника USART
 * прерываний от него.Далее автомат переходит в состяние простоя,
 * на фоне которого происходит ожидание и прием очередного пакета MODBUS. 
 */
//------------------------------------------------------------------------------
extern uint8_t regINP; //регистров in
extern volatile uint8_t regAct; //маска активных регистров
extern uint8_t rdMask; //маска регистров чтения

void __interrupt() isr(void) {

    //Обработка прерывания от таймера 0, для формирования GAP интервалов
    if (INTCONbits.T0IF && INTCONbits.T0IE) {
        TMR0 = 131; //дополнение до 256 к 125 (62,5us 16000000 div 2)
        //если находимся в режиме приема пакета(разешены прерывания PIE1bits.RCIE)
        // то каждый тик уменьшаем интервал GAP, если он уменьшился до 0,
        // и больше данных в RxUSART не поступает -> пакет принят полностью
//        PORT_TxE = ~PORT_TxE;
        if (PIE1bits.RCIE) {
            if (MODBUS.gapCnt > 0) {
                MODBUS.gapCnt--;
            } else {
                //PORTAbits.RA0 = 0;
                MODBUS.gapCnt = MODBUS.gapTime;
                if (MODBUS.cntByte > 0) { //принято что-то?
                    PIE1bits.RCIE = 0; //запрещаем прерывания приема
                    //идем на обработку принятого пакета в основном цикле
                    MODBUS.stpFunc = 2; //=>toSlaveStepHandler
                }
            }
        }
        INTCONbits.T0IF = 0; //Сбрасываем флаг прерывания от таймера 0
    }

    if (IOCAFbits.IOCAF3 && INTCONbits.IOCIE) {
        IOCAFbits.IOCAF3 = 0;
        regAct = regAct | rdMask;
    }

    //------------------------------------------------------------------------------
    //обработчик прерывания от периферии
    if (INTCONbits.PEIE == 1) {
        //Обработка прерывания от таймера 1, для формирования системных тиков
        if (PIR1bits.TMR1IF && PIE1bits.TMR1IE) {
            PIR1bits.TMR1IF = 0;
            TMR1H = _TMR1H;
            TMR1L = _TMR1L;

            timeCount();
        }
        //------------------------------------------------------------------------------
        //обработчик прерывания от передатчика УАРТ       
        if (PIE1bits.TXIE && PIR1bits.TXIF) {
            //следующий символ на передачу
            if (MODBUS.cntByte < MODBUS.sendLen) {
                TXREG = MODBUS.buffer[MODBUS.cntByte];
                MODBUS.cntByte++;
            } else { // все передано СТОП!
                PIE1bits.TXIE = 0; //запрещаем прерывание передачи
                //будем ждать освобождения буфера передачи USART
                MODBUS.stpFunc = 0; //=> toFinishSendHandler;
            }
        }
        //------------------------------------------------------------------------------
        //обработчик прерывания от приемника УАРТ
        if (PIE1bits.RCIE && PIR1bits.RCIF) {
            //После приема каждого байта восстанавливаем защитный интервал приема         
            MODBUS.gapCnt = MODBUS.gapTime; //Установили интервал
            //        PORTAbits.RA0 = 1;
            //PORTAbits.RA1 ^= 1;
            if (RCSTAbits.FERR || RCSTAbits.OERR) //Были ошибки?
            {
                //В случае ошибки приемника
                RCSTAbits.CREN = 0; //Отключаем приемник для сброса ошибки
                NOP();
                //Включаем приемник для продолжения работу УАРТ
                RCSTAbits.CREN = 1;
                //для сброса остальных принятых байт в NULL установим
                MODBUS.cntByte = MAX_PACK_SIZE;
            } else {
                while (PIR1bits.RCIF) {
                    //Записываем очередной байт в пакет данных ModBus
                    //Лишние данные сбрасываем
                    if (MODBUS.cntByte < MAX_PACK_SIZE) {
                        MODBUS.buffer[MODBUS.cntByte] = RCREG;
                        MODBUS.cntByte++;
                    } else {
                        //TODO прочитать RCREG в NULL) сбросить флаг PIR1bits.RCIF
                        MODBUS.sendLen = RCREG;
                    }

                }
            }

        }
        //------------------------------------------------------------------------------
        //обработчик прерывания от I2C
        if (PIE2bits.BCL1IE && PIR2bits.BCL1IF) {
            I2C_MasterIsr();
        }
        if (PIE1bits.SSP1IE && PIR1bits.SSP1IF) {
            I2C_MasterIsr();
        }
    }
}

